/// start - data/embeddedRoutes
/*
 * Module URI: data/embeddedRoutes
 * SRC: data/embeddedRoutes.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("data/embeddedRoutes", function(exports, globals, module){
		const embeddedRoutes = [
		  { path: "/", loadApp: "app/home/home", routeKey:"home"  },
		  { path: "/recipe", loadApp: "app/recipe/recipe_main", routeKey:"recipe" },
		  { path: /^\/recipe\/(\d+)$/, loadApp: "app/recipe/recipe_detail" },
		  { path: "/recipe/search", loadApp: "app/recipe/recipe_search" },
		  { path: "/auth/login", loadApp: "app/login/login", routeKey:"auth"  },
		  { path: "/users/mypage", loadApp: "app/mypage/mypage", routeKey:"auth"},
		  { path: "/users/payment", loadApp: "app/payment/paycheck"},
		  { path: "/users/myinfo" , loadApp: "app/mypage/myinfo"},
		  { path: "/fridge", loadApp: "app/fridge/fridge_main", routeKey:"fridge"  },
		  { path: "/recipe/form", loadApp: "app/recipe/recipe_form" }, // 레시피 등록
		  { path: /^\/recipe\/form\/(\d+)$/, loadApp: "app/recipe/recipe_form" }, // 레시피 수정
		  { path: "/auth/register", loadApp: "app/login/register"},
		  { path: "/auth/password", loadApp: "app/mypage/passwordchange"},
		  { path: "/fridge", loadApp: "app/fridge/fridge_main" },
		  { path: "/fridge/auto", loadApp: "app/fridge/fridge_auto" }
		];

		exports.embeddedRoutes = embeddedRoutes;
	});
})();
/// end - data/embeddedRoutes
/// start - data/recipeCategoryItems
/*
 * Module URI: data/recipeCategoryItems
 * SRC: data/recipeCategoryItems.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("data/recipeCategoryItems", function(exports, globals, module){
		/************************************************
		 * recipeCategoryItems.module.js
		 * Created at 2025. 4. 24. 오후 5:29:57.
		 *
		 * @author gyrud
		 ************************************************/

		const typeCategoryItems = ["찌개","국/탕", "반찬", "면", "밥", "만두"];
		const situationCategoryItems = ["일상", "초간단", "접대","고급","다이어트","술안주", "도시락","건강식","야식","가족"];
		const methodCategoryItems = ["끓이기","찌기","굽기","볶기","튀기기","기타"];

		exports.typeCategoryItems = typeCategoryItems;
		exports.situationCategoryItems = situationCategoryItems;
		exports.methodCategoryItems = methodCategoryItems;
	});
})();
/// end - data/recipeCategoryItems
/// start - data/recipeInfoSelectItems
/*
 * Module URI: data/recipeInfoSelectItems
 * SRC: data/recipeInfoSelectItems.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("data/recipeInfoSelectItems", function(exports, globals, module){
		/************************************************
		 * recipeInfoSelectItems.module.js
		 * Created at 2025. 4. 24. 오후 5:55:00.
		 *
		 * @author gyrud
		 ************************************************/

		const difficulty = ["쉬움", "보통", "어려움"];
		const cookingTime = ["5분 이내","5분~10분","10분~30분","30분~1시간","1시간~2시간","2시간 이상"];

		exports.difficulty = difficulty;
		exports.cookingTime = cookingTime;
	});
})();
/// end - data/recipeInfoSelectItems
/// start - module/common/isLastPathSegmentNumber
/*
 * Module URI: module/common/isLastPathSegmentNumber
 * SRC: module/common/isLastPathSegmentNumber.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/common/isLastPathSegmentNumber", function(exports, globals, module){
		/************************************************
		 * isLastPathSegmentNumber.module.js
		 * Created at 2025. 4. 28. 오후 2:47:28.
		 *
		 * @author gyrud
		 ************************************************/

		const isLastPathSegmentNumber=()=> {
			const pathName = window.location.pathname;
		    const lastSegment = pathName.split("/").pop();
		    const numberValue = Number(lastSegment);
		    const isNumber = !isNaN(numberValue);
		    return [isNumber, numberValue];
		};

		exports.isLastPathSegmentNumber = isLastPathSegmentNumber;
	});
})();
/// end - module/common/isLastPathSegmentNumber
/// start - module/common/showToast
/*
 * Module URI: module/common/showToast
 * SRC: module/common/showToast.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/common/showToast", function(exports, globals, module){
		/************************************************
		 * showToast.module.js
		 * Created at 2025. 5. 2. 오전 11:30:33.
		 *
		 * @author gyrud
		 ************************************************/

		const showToast=(message, duration = 3000)=>{
		  // 이미 스타일이 추가되어 있다면 중복 방지
		  if (!document.getElementById('toast-style')) {
		    const style = document.createElement('style');
		    style.id = 'toast-style';
		    style.textContent = `
      .toast-container {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background-color: #F59760;
        color: #ffffff;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
		font-weight: bold;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease, transform 0.3s ease;
        pointer-events: none;
      }
      .toast-container.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-10px);
      }
    `;
		    document.head.appendChild(style);
		  }

		  const toast = document.createElement('div');
		  toast.className = 'toast-container';
		  toast.textContent = message;
		  document.body.appendChild(toast);

		  // 토스트 보여주기
		  requestAnimationFrame(() => {
		    toast.classList.add('show');
		  });

		  // 자동 제거
		  setTimeout(() => {
		    toast.classList.remove('show');
		    setTimeout(() => {
		      document.body.removeChild(toast);
		    }, 300); // CSS transition 시간과 일치
		  }, duration);
		};

		exports.showToast = showToast;
	});
})();
/// end - module/common/showToast
/// start - module/common/Slidifiy
/*
 * Module URI: module/common/Slidifiy
 * SRC: module/common/Slidifiy.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/common/Slidifiy", function(exports, globals, module){
		/************************************************
		 * Slidify2.module.js
		 * Created at 2019. 1. 3. 오후 12:56:32.
		 *
		 * @author jeeeyul
		 ************************************************/

		/**
		 * 
		 * @param {Event} e
		 */
		function eventStopper(e) {
			e.stopPropagation();
			e.preventDefault();
		}

		/**
		 * 
		 * @param {cpr.controls.Container} container
		 */
		function SlideView(container) {
			this._container = container;
			/** @type cpr.controls.layouts.FlowLayout */
			this._layout = container.getLayout();
		};

		/**
		 * 한 페이지에서 표시할 콘텐츠 수
		 */
		SlideView.prototype.showCount = 2;

		/**
		 * 페이지 내 한 컨텐츠의 너비. 0인 경우 비율로 균등 분배합니다.
		 */
		SlideView.prototype.itemSize = 0;

		/**
		 * 자동 재생시 애니메이션의 길이. 단위 초.
		 */
		SlideView.prototype.autoPlayDuration = 1.0;

		/**
		 * 자동 재생시, 각 재생간의 간격. 단위 초. 0 이상의 값을 주면 start()시 자동 재생이 시작됩니다. 0을 주는 경우, 자동으로 재생을 시작하지 않습니다.
		 */
		SlideView.prototype.autoPlayDelay = 0;

		/**
		 * 터치 또는 마우스로 드래그중 놓았을 때, 스내핑 애니메이션의 길이. 단위 초.
		 */
		SlideView.prototype.snapDuration = 0.3;

		/**
		 * 페이지니션을 표시할 것인지 여부.
		 */
		SlideView.prototype.showPaginition = true;

		/**
		 * 좌우 버튼의 너비
		 */
		SlideView.prototype.navigationButtonWidth = 30;

		/** 
		 * 좌우버튼에 추가적으로 줄 클래스 명.
		 * @type String 
		 */
		SlideView.prototype.navigationButtonClassName = null;

		/**
		 * 무한 스크롤 사용 여부.
		 */
		SlideView.prototype.useInfiniteScroll = false;

		/**
		 * 네비게이션 버튼 표시 스타일
		 * <li>hover: 컨테이너 가장자리에 호버 시킴</li>
		 * <li>outside: 컨테이나 가장자리 바깥쪽에 표시</li>
		 * <li>content-hover: 가운데 정렬된 콘텐츠의 가장자리에 호버 시킴</li>
		 * <li>content-outside: 가운데 정렬된 콘텐츠의 가장자리에 바깥쪽에 표시</li></li>
		 * <li>none: 버튼 표시 안함</li>
		 */
		SlideView.prototype.navigationButtonStyle = "inside";

		/**
		 * 시작 페이지 번호 0부터 시작.
		 */
		SlideView.prototype.initialPage = 0;

		/**
		 * <li>left: 시작 컨트롤이 왼쪽 끝에서 시작</li>
		 * <li>center: 시작 컨트롤이 가운데에서 시작</li>
		 * <li>right: 시작 컨트롤이 오른쪽 끝에서 시작</li>
		 */
		SlideView.prototype.startAlign = "left";

		/**
		 * @type SlidePaginition
		 */
		SlideView.prototype._paginition = null;
		/**
		 * @type cpr.controls.UIControl[]
		 */
		SlideView.prototype._originalChildren = [];
		SlideView.prototype._knownScreenX = -1;
		SlideView.prototype._initialScrollLeft = -1;
		/** @type cpr.controls.Container */
		SlideView.prototype._innerContainer = null;
		/** @type cpr.controls.layouts.FlowLayout */
		SlideView.prototype._innerLayout = null;

		/** @type cpr.geometry.Rectangle */
		SlideView.prototype._knownBounds = null;

		/** @type cpr.controls.Button */
		SlideView.prototype._prevButton = null;

		/** @type cpr.controls.Button */
		SlideView.prototype._nextButton = null;

		/** @type cpr.animation.Animator */
		SlideView.prototype._activeAnimator = null;
		SlideView.prototype._autoPlayTimerID = -1;

		SlideView.prototype._transform = function() {
			var height = this._container.getViewPortRect().height;
			this._container.style.addClass("cl-unselectable");
			this._layout.horizontalAlign = "center";
			this._layout.scrollable = false;
			this._originalChildren = this._container.getChildren();

			this._innerContainer = new cpr.controls.Container();
			var layout = new cpr.controls.layouts.FlowLayout();
			layout.lineWrap = false;
			layout.scrollable = false;
			layout.spacing = this._layout.spacing;
			this._innerContainer.setLayout(layout);
			this._innerLayout = layout;
			this._layout.spacing = 0;
			this._layout.scrollable = false;

			var itemConstraint = {
				height: "100%"
			};

			var itemSizeExpression = this.itemSize + "px";

			if (this.itemSize <= 0) {
				itemSizeExpression = "(100% - " + (this.showCount) * layout.spacing + "px) / " + this.showCount;
				itemConstraint.width = "calc(" + itemSizeExpression + ")";
			} else {
				itemConstraint.width = this.itemSize + "px";
			}

			if (this.useInfiniteScroll === false) {
				switch (this.startAlign) {
					case "center":
						{
							var padder = new cpr.controls.Output();
							padder.style.addClass("placeholder");
							this._innerContainer.addChild(padder, {
								width: cpr.utils.Util.template("calc((100% - ${spacing} - ${eachWidth}) / 2 - ${spacing})", {
									eachWidth: "(" + itemSizeExpression + ")",
									spacing: layout.spacing + "px"
								}),
								height: "100%"
							});
							break;
						}

					case "right":
						{
							var padder = new cpr.controls.Output();
							padder.style.addClass("placeholder");
							this._innerContainer.addChild(padder, {
								width: cpr.utils.Util.template("calc(100% - 2 * ${spacing} - ${eachWidth})", {
									eachWidth: "(" + itemSizeExpression + ")",
									spacing: layout.spacing + "px"
								}),
								height: "100%"
							});
							break;
						}
				}
			}

			this._container.getChildren().forEach((function( /* cpr.controls.UIControl */ each, idx) {
				each.userAttr("-snap-point", "true");
				this._innerContainer.addChild(each, itemConstraint);
			}).bind(this));
			this._container.addChild(this._innerContainer, {
				width: this.itemSize > 0 ? this.showCount * this.itemSize + (this.showCount - 1) * layout.spacing + "px" : "100%",
				height: "100%"
			});

			this._paginition = new SlidePaginition(this);
			this._container.getParent().floatControl(this._paginition.control);
		}

		/**
		 * 슬라이드뷰를 시작합니다.
		 * 시작하기전 모든 설정이 마쳐져야 합니다.
		 */
		SlideView.prototype.start = function() {
			if (this._container.getActualRect().width === 0) {
				cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this.start.bind(this));
				return;
			}

			this._transform();

			this._onMouseDown = this._onMouseDown.bind(this);
			this._onMouseUp = this._onMouseUp.bind(this);
			this._onMouseMove = this._onMouseMove.bind(this);

			this._onTouchEnd = this._onTouchEnd.bind(this);
			this._onTouchStart = this._onTouchStart.bind(this);
			this._onTouchMove = this._onTouchMove.bind(this);

			this._doUpdateButtons = _.debounce(this._doUpdateButtons.bind(this), 500);
			this._updateActivePageButton = _.debounce(this._updateActivePageButton.bind(this), 50);

			this._onResize = this._onResize.bind(this);

			this._innerContainer.addEventListener("scroll", this._updateActivePageButton);
			this._container.addEventListener("mousedown", this._onMouseDown);
			this._container.addEventListener("touchstart", this._onTouchStart);
			this._container.addEventListenerOnce("dispose", this._handleDispose.bind(this));
			cpr.core.NotificationCenter.INSTANCE.subscribe("main-size-changed", this, this._updateButtons);
			cpr.core.NotificationCenter.INSTANCE.subscribe("swipe-transition-occured", this, this._onResize);
			cpr.core.NotificationCenter.INSTANCE.subscribe(cpr.core.SystemTopics.RESIZE, this, this._onResize);
		//	cpr.core.NotificationCenter.INSTANCE.subscribe(TAB_FOLDER_CHANGED, this, this._onResize);

			this._updateActivePageButton();

			if (this.autoPlayDelay > 0) {
				this.autoPlay();
			}

			if (this.initialPage > 0) {
				cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
					if (this._container.disposed) {
						return;
					}
					this.setActivePage(this.initialPage);
				}).bind(this));
			}

			cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
				if (this._container.disposed) {
					return;
				}
				this._doUpdateButtonsImmediatly();
			}).bind(this));
		};

		/**
		 * 자동 재생을 시작합니다. autoPlayDelay가 지정된 경우, 슬라이드 시작시 자동으로 재생이 시작됩니다.
		 */
		SlideView.prototype.autoPlay = function() {
			if (this._autoPlayTimerID >= 0) {
				return;
			}
			this._autoPlayTimerID = setInterval(this.showNext.bind(this), (this.autoPlayDelay + this.autoPlayDuration) * 1000);
		};

		/**
		 * 자동 재생중인 경우, 자동 재생을 중단합니다.
		 */
		SlideView.prototype.stopAutoPlay = function() {
			if (this._autoPlayTimerID >= 0) {
				clearInterval(this._autoPlayTimerID);
				this._autoPlayTimerID = -1;
			}
		};

		SlideView.prototype._handleDispose = function() {
			this.stopAutoPlay();
			this._container.removeEventListener("mousedown", this._onMouseDown);
			this._container.removeEventListener("touchstart", this._onTouchStart);
			cpr.core.NotificationCenter.INSTANCE.unsubcribeAllTopic(this);
		};

		/**
		 * 터치 시작 처리 핸들러
		 * @param {cpr.events.CTouchEvent} e
		 */
		SlideView.prototype._onTouchStart = function(e) {
			if (this._activeAnimator) {
				return;
			}

			var touch = e.targetTouches.item(0);
			this._knownScreenX = touch.screenX;
			this._initialScrollLeft = this._innerContainer.getViewPortRect().x;

			window.addEventListener("touchmove", this._onTouchMove);
			window.addEventListener("touchend", this._onTouchEnd);

			e.stopPropagation();
			this.stopAutoPlay();
		};

		/**
		 * 터치 이동 핸들러
		 * @param {cpr.events.CTouchEvent} e
		 */
		SlideView.prototype._onTouchMove = function(e) {
			var touch = e.targetTouches.item(0);
			this._handleMove(touch.screenX);
			e.stopPropagation();
			e.preventDefault();
		};

		/**
		 * 터치 종료 핸들러
		 * @param {cpr.events.CTouchEvent} e
		 */
		SlideView.prototype._onTouchEnd = function(e) {
			window.removeEventListener("touchmove", this._onTouchMove);
			window.removeEventListener("touchend", this._onTouchEnd);
			this._knownScreenX = -1;
			this._snapToClosestContent();
		};

		/**
		 * 마우스 다운 핸들러
		 * @param {cpr.events.CMouseEvent} e
		 */
		SlideView.prototype._onMouseDown = function(e) {
			if (e.button !== 0) {
				return;
			}
			if (this._activeAnimator) {
				return;
			}

			// 마우스가 다운 된 위치를 기억 해 둠.
			this._knownScreenX = e.screenX;

			// 현재 뷰포트의 위치를 기억해 둠.
			this._initialScrollLeft = this._innerContainer.getViewPortRect().x;

			window.addEventListener("mouseup", this._onMouseUp);
			window.addEventListener("mousemove", this._onMouseMove);

			// 혹시라도 마우스 업이 내비게이션 버튼에서 일어나, 드래깅 상태가 지속되는 문제를 미연에 방지.
			if (this._prevButton && this._nextButton) {
				this._prevButton.removeEventListener("mouseup", eventStopper);
				this._nextButton.removeEventListener("mouseup", eventStopper);
			}

			this.stopAutoPlay();
			e.stopPropagation();
		};

		/**
		 * 마우스/터치의 이동 처리. 
		 * @param {Number} screenX
		 */
		SlideView.prototype._handleMove = function(screenX) {
			var container = this._innerContainer;
			var layout = this._innerLayout;

			// 스크롤 불능일 경우 중단.
			if (container.getViewPortRect().width >= container.getContentPaneRect().width) {
				return;
			}

			if (this._knownScreenX < 0) {
				return;
			}

			// 터치/마우스의 이동량을 구함.
			var delta = this._knownScreenX - screenX;

			// 새로운 뷰포트의 위치
			var newScrollLeft = this._initialScrollLeft + delta;

			// 왼쪽 경계선 너머로 스크롤.
			if (newScrollLeft < 0) {
				if (this.useInfiniteScroll === false) {
					container.scrollTo(0, 0);
					return;
				}
				var children = container.getChildren();

				// 오른쪽 끝 자식을 떼어 내어 왼쪽으로 이동시키고, 스크롤 상황을 업데이트 함.
				var lastChild = children[children.length - 1];
				container.reorderChild(lastChild, 0);
				var fix = this._innerLayout.spacing + lastChild.getOffsetRect().width;
				this._initialScrollLeft += fix;
				container.scrollTo(fix, 0);
				cpr.core.DeferredUpdateManager.INSTANCE.update();
				return;
			}

			// 오른쪽 경계선 너머로 스크롤.
			else if (newScrollLeft + container.getViewPortRect().width > container.getContentPaneRect().width) {
				if (this.useInfiniteScroll === false) {
					container.scrollTo(container.getContentPaneRect().width - container.getViewPortRect().width, 0);
					return;
				}
				var children = container.getChildren();

				// 첫번째 자식을 떼어내어 오른쪽 끝으로 이동시키고 스크롤 상황을 업데이트 함.
				var firstChild = children[0];

				var fix = firstChild.getOffsetRect().width + this._innerLayout.spacing;
				this._initialScrollLeft -= fix;
				container.reorderChild(firstChild, children.length);
				container.adjustScroll(-fix, 0);
				cpr.core.DeferredUpdateManager.INSTANCE.update();
				return;
			}

			container.scrollTo(newScrollLeft, 0);
		}

		/**
		 * 
		 * @param {MouseEvent} e
		 */
		SlideView.prototype._onMouseMove = function(e) {
			this._handleMove(e.screenX);
			e.preventDefault();
		};

		/**
		 * 
		 * @param {MouseEvent} e
		 */
		SlideView.prototype._onMouseUp = function(e) {
			window.removeEventListener("mouseup", this._onMouseUp);
			window.removeEventListener("mousemove", this._onMouseMove);
			this._knownScreenX = -1;
			this._snapToClosestContent();
			if (this._prevButton && this._nextButton) {
				this._prevButton.addEventListener("mouseup", eventStopper);
				this._nextButton.addEventListener("mouseup", eventStopper);
			}
		};

		SlideView.prototype._updateButtons = function() {
			if (this._container.disposed) {
				return;
			}
			if (this._prevButton) {
				this._prevButton.dispose();
				this._prevButton = null;
			}
			if (this._nextButton) {
				this._nextButton.dispose();
				this._nextButton = null;
			}

			this._paginition.control.visible = false;
			this._doUpdateButtons();
		}

		SlideView.prototype._doUpdateButtonsImmediatly = function() {
			if (this._container.disposed) {
				return;
			}

			this._knownBounds = this._container.getOffsetRect();

			var shouldShowButtons = this._innerContainer.getChildrenCount() > 1 && this._innerContainer.getViewPortRect().width < this._innerContainer.getContentPaneRect().width;
			if (!shouldShowButtons) {
				if (this._prevButton) {
					this._prevButton.dispose();
					this._prevButton = null;
				}
				if (this._nextButton) {
					this._nextButton.dispose();
					this._nextButton = null;
				}
				this._paginition.control.visible = false;
			} else {
				this._paginition.control.visible = this.showPaginition;
				if (this.showPaginition) {
					this._paginition.control.style.css({
						top: this._knownBounds.bottom + "px",
						left: this._knownBounds.left + "px",
						width: this._knownBounds.width + "px"
					});
					this._paginition.control.style.animateFrom({
						"opacity": "0"
					});
				}

				if (this.navigationButtonStyle != "none") {
					this._prevButton = new cpr.controls.Button();
					this._prevButton.style.addClass("slide-button");
					this._prevButton.style.addClass("slide-prev-button");
					if (this.navigationButtonClassName) {
						this._prevButton.style.addClass(this.navigationButtonClassName);
					}
					this._prevButton.addEventListener("click", (function() {
						this.stopAutoPlay();
						this.showPrev();
					}).bind(this));

					this._prevButton.addEventListener("mousedown", eventStopper);
					this._prevButton.addEventListener("mouseup", eventStopper);
					this._prevButton.addEventListener("click", eventStopper);
					this._nextButton = new cpr.controls.Button();
					this._nextButton.style.addClass("slide-button");
					this._nextButton.style.addClass("slide-next-button");
					if (this.navigationButtonClassName) {
						this._nextButton.style.addClass(this.navigationButtonClassName);
					}
					this._nextButton.addEventListener("click", (function() {
						this.stopAutoPlay();
						this.showNext();
					}).bind(this));
					this._nextButton.addEventListener("mousedown", eventStopper);
					this._nextButton.addEventListener("mouseup", eventStopper);
					this._nextButton.addEventListener("click", eventStopper);

					var superContainer = this._container.getParent();
					var leftCosntraint = {
						left: this._knownBounds.left + "px",
						top: this._knownBounds.top + "px",
						height: this._knownBounds.height + "px",
						width: this.navigationButtonWidth + "px"
					};
					var rightConstraint = {
						left: this._knownBounds.right - this.navigationButtonWidth + "px",
						top: this._knownBounds.top + "px",
						height: this._knownBounds.height + "px",
						width: this.navigationButtonWidth + "px"
					};
					switch (this.navigationButtonStyle) {
						case "inside":
							{
								break;
							}
						case "content-hover":
							{
								var offsetRect = this._innerContainer.getOffsetRect();
								leftCosntraint.left = offsetRect.x + "px";
								leftCosntraint.top = offsetRect.y + "px";
								rightConstraint.left = offsetRect.right - this.navigationButtonWidth + "px";
								rightConstraint.top = offsetRect.y + "px";
								superContainer = this._container;
								break;
							}
						case "content-outside":
							{
								var offsetRect = this._innerContainer.getOffsetRect();
								leftCosntraint.left = offsetRect.x - this.navigationButtonWidth + "px";
								leftCosntraint.top = offsetRect.y + "px";
								rightConstraint.left = offsetRect.right + "px";
								rightConstraint.top = offsetRect.y + "px";
								superContainer = this._container;
								break;
							}
						case "outside":
							{
								leftCosntraint.left = this._knownBounds.left - this.navigationButtonWidth + "px";
								rightConstraint.left = this._knownBounds.right + "px";
								break;
							}
					}

					superContainer.floatControl(this._prevButton, leftCosntraint);
					superContainer.floatControl(this._nextButton, rightConstraint);
					this._prevButton.visible = false;
					this._nextButton.visible = false;
					cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
						if (this._container.disposed) {
							return;
						}
						if (this._prevButton) {
							this._prevButton.visible = true;
							this._prevButton.style.animateFrom({
								"opacity": "0"
							});
						}
						if (this._nextButton) {
							this._nextButton.visible = true;
							this._nextButton.style.animateFrom({
								"opacity": "0"
							});
						}
					}).bind(this));

				}
				//		this._snapToClosestContent();
			}

		}

		SlideView.prototype._doUpdateButtons = function() {
			if (this._container.disposed) {
				return;
			}
			this._doUpdateButtonsImmediatly();
		};

		SlideView.prototype._onResize = function() {
			if (this._container.disposed) {
				return;
			}

			// 처음 그리는 경우.
			if (!this._knownBounds) {
				this._updateButtons();
			}

			// 그외의 경우, 컨테이너의 영역이 달라진 경우에만 새로 그림.
			else if (this._knownBounds.equals(this._container.getOffsetRect()) === false) {
				this._updateButtons();
			}
		};

		SlideView.prototype.showPrev = function() {
			if (this._activeAnimator) {
				return;
			}
			this._snapToClosestContent(0);
			this._knownScreenX = 0;
			this._initialScrollLeft = this._innerContainer.getViewPortRect().x;
			var animator = new cpr.animation.Animator(this.autoPlayDuration, cpr.animation.TimingFunction.EASE_IN_OUT);
			var me = this;
			var fullWidth = this._innerContainer.getViewPortRect().width;
			animator.addTask(function(p) {
				me._handleMove(p * fullWidth);
			});
			this._activeAnimator = animator;
			animator.run().then((function() {
				this._activeAnimator = null;
			}).bind(this));
		};

		SlideView.prototype.showNext = function() {
			if (this._activeAnimator) {
				return;
			}

			var target = this._findMostCloseControl(this._innerContainer.getViewPortRect().right);
			if (target) {
				var offset = target.getOffsetRect().right;
				this._innerContainer.scrollTo(offset - this._innerContainer.getViewPortRect().width, 0, this.autoPlayDuration);
			}
		};

		/**
		 * 가장 가까운 컨텐츠로 스크롤 시킵니다.
		 * @param {Number} viewportX
		 * @param {Boolean} rightFirst (Optional)
		 */
		SlideView.prototype._findMostCloseControl = function(viewportX, rightFirst) {
			if (rightFirst === undefined) {
				rightFirst = false;
			}
			var shortedDistance = Number.MAX_VALUE;
			/** @type cpr.controls.UIControl */
			var controlToScroll = null;
			var children = this._innerContainer.getChildren();
			if (rightFirst) {
				children = children.reverse();
			}
			children.filter(function( /* cpr.controls.UIControl */ each) {
				return each.userAttr("-snap-point") == "true";
			}).forEach((function( /* cpr.controls.UIControl */ each) {
				var eachDistance = Math.abs(each.getOffsetRect().x - this._innerLayout.spacing - viewportX);
				if (eachDistance < shortedDistance) {
					shortedDistance = eachDistance;
					controlToScroll = each;
				}
			}).bind(this));
			return controlToScroll;
		};

		/**
		 * 가장 가까운 컨텐츠로 스크롤 시킵니다.
		 */
		SlideView.prototype._snapToClosestContent = function(duration) {
			if (duration == null) {
				duration = this.snapDuration;
			}
			if (this._container.disposed) {
				return;
			}

			var viewPortRect = this._innerContainer.getViewPortRect();
			var controlToScroll = this._findMostCloseControl(viewPortRect.x)
			if (controlToScroll && viewPortRect.width >= controlToScroll.getOffsetRect().width) {
				this._innerContainer.scrollTo(controlToScroll.getOffsetRect().x - this._innerLayout.spacing, 0, duration, cpr.animation.TimingFunction.EASE_OUT_CUBIC);
			}
		};

		SlideView.prototype.getActivePage = function() {
			var control = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
			return Math.floor(this._originalChildren.indexOf(control) / this.showCount);
		};

		/**
		 * @param {Number} page
		 * @param {Number} duration (Optional)
		 */
		SlideView.prototype.setActivePage = function(page, duration) {
			if (this._container.disposed) {
				return;
			}
			if (duration == null) {
				duration = 0;
			}
			var targetControl = this._originalChildren[page * this.showCount];
			if (targetControl) {
				console.log(targetControl);
				this._innerContainer.scrollTo(targetControl.getOffsetRect().x - this._innerLayout.spacing, 0, duration);
			}
		};

		SlideView.prototype._updateActivePageButton = function() {
			if (this._container.disposed) {
				return;
			}
			var activePage = this.getActivePage();
			this._paginition.control.getChildren().forEach(function( /* cpr.controls.Button */ each, idx) {
				if (idx == activePage) {
					each.style.addClass("active");
				} else {
					each.style.removeClass("active");
				}
			});
		}

		/**
		 * 
		 * @param {SlideView} owner
		 */
		function SlidePaginition(owner) {
			this._owner = owner;
			this.control = new cpr.controls.Container();
			this.control.visible = false;
			var layout = new cpr.controls.layouts.FlowLayout();
			layout.horizontalMargin = 0;
			layout.verticalMargin = 0;
			layout.horizontalAlign = "center";
			layout.verticalAlign = "middle";
			this.control.setLayout(layout);
			this._populateButtons();
		};

		/** @type cpr.controls.Container */
		SlidePaginition.prototype.control = null;

		SlidePaginition.prototype._populateButtons = function() {
			var pageCount = Math.ceil(this._owner._originalChildren.length / this._owner.showCount);
			for (var idx = 0; idx < pageCount; idx++) {
				(function(idx) {
					var pageButton = new cpr.controls.Button();
					pageButton.style.addClass("slide-page-button");
					pageButton.addEventListener("click", (function(e) {
						this._owner.stopAutoPlay();
						if (this._owner._activeAnimator) {
							this._owner._activeAnimator.stop();
							this._owner._activeAnimator = null;
						}
						this._owner.setActivePage(idx, this._owner.autoPlayDuration);
					}).bind(this));
					this.control.addChild(pageButton, {
						width: "20px",
						height: "20px",
						autoSize: "both"
					});
				}).bind(this)(idx);
			}
		};

		/**
		 * 
		 * @param {cpr.controls.Container} container
		 */
		exports.slidify = function(container) {
			return new SlideView(container);
		};

		exports.SlideView = SlideView;
	});
})();
/// end - module/common/Slidifiy
/// start - module/quicksearch/quickSearch
/*
 * Module URI: module/quicksearch/quickSearch
 * SRC: module/quicksearch/quickSearch.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/quicksearch/quickSearch", function(exports, globals, module){
		/************************************************
		 * autoComplate.module.js
		 * Created at 2020. 4. 28. 오전 9:53:28.
		 * 
		 * Version 1.3
		 * Updated Date : 2021-11-24
		 * 
		 * @author daye
		 ************************************************/

		/*
		 * 본 모듈은 인풋계열 컨트롤(인풋박스, 서치인풋, 마스크에디터, 텍스트에리어, 넘버에디터,  데이트인풋, 트리셀) 에서 텍스트를 작성했을 때 어시스트를 제공하는 모듈입니다.
		 * 사용자 속성(showAssist)의 값이 Y인 컨트롤만 대상으로 모듈에서 제공하는 기능을 확인 할 수 있습니다.
		 * 서브미션을 통해 데이터를 호출할 경우에는 해당 컨트롤에 사용자속성(submit-action)을  추가하여 action 경로를 설정하십시오.
		 * 
		 * setRank 함수를 통해 리스트박스에 보여줄 수 있는 최상위 개수를 지정 할 수 있습니다.
		 */


		/************************************************
		 * 전역 변수 (변경 가능)
		 ************************************************/
		/**
		 * 모듈 사용 여부
		 * @type {Boolean}
		 */
		var mbAssist = true;

		/**
		 * 어시스트 정렬
		 * @type {String}
		 */
		var msSort = "label ASC";

		/**
		 * 자연어 사용 여부
		 * @type {Boolean}
		 */
		var mbUseNatureLan = true;

		/**
		 * 자연어 검색을 위한 delay 시간 (단위 : ms)
		 * @type {Number}
		 */
		var mnWait = 500;

		/**
		 * 사용자 속성 (모듈 적용 컨트롤)
		 * @type {String}
		 */
		var ATTR_USE_ASSIST = "showAssist";

		/**
		 * 사용자 속성 (서브미션 action 경로)
		 * @type {String}
		 */
		var ATTR_SUBMIT_ACTION = "submit-action";

		/**
		 * 메뉴 컨트롤의 리스트 스타일 클래스
		 * @type {String}
		 */
		var msClPopCls = "cl-popup";

		/**
		 * 메뉴가 컨트롤의 위쪽에 띄워질 때의 스타일 클래스
		 * @type {String}
		 */
		var msClTopCls = "cl-top";

		/**
		 * 메뉴가 컨트롤의 아래쪽에 띄워질 때의 스타일 클래스
		 * @type {String}
		 */
		var msClBottomCls = "cl-bottom";

		/**
		 * 메뉴 아이템의 말줄임 스타일 클래스
		 * @type {String}
		 */
		var msEllipsisCls = "ellipsis";

		/**
		 * 메뉴 스타일 클래스
		 * @type {String}
		 */
		var msQuickSrchCls = "auto-complete";


		/************************************************
		 * 전역 변수 (변경 불가능)
		 ************************************************/
		/**
		 * 어시스트를 제공하기 위한 메뉴컨트롤
		 * @type {cpr.controls.Menu}
		 */
		var mcMenu = null;

		/**
		 * mcMenu에 바인딩 할 데이터셋
		 * @type {cpr.data.DataSet}
		 */
		var mcDataset = null;

		var msDataSetLabel = null ;  //dataSet label Column name 
		var msDataSetValue = null ;  //dataSet value Column name
		var msDataSetTooltip = null ;  //dataSet tooltip column name 
		 

		/**
		 * 최상위 개수
		 * @type {Number}
		 */
		var mnRank = 0;

		/**
		 * 변경 전 value 
		 * @type {String}
		 */
		var msBeforeValue = "";


		/************************************************
		 * 이벤트 버스 (keyup)
		 ************************************************/
		if(mbAssist) cpr.events.EventBus.INSTANCE.addFilter("keyup", fn_keyup);

		cpr.events.EventBus.INSTANCE.addFilter("keydown", function(/* cpr.events.CKeyboardEvent */ e){
			var control = e.control;
			
			if("displayText" in control == false) return;
			
			// 그리드에서 어시스트를 사용 할 경우, 기본동작(행이동) 방지
			if(e.keyCode == cpr.events.KeyCode.DOWN || e.keyCode == cpr.events.KeyCode.UP || e.keyCode == cpr.events.KeyCode.ESC || e.keyCode == cpr.events.KeyCode.ENTER) {
				if(control.getParent().type == "grid" && mcMenu) {
					if(mcMenu.isFloated()) {
						if(mcMenu.getItemCount() == 0) return;
						e.stopPropagation();
					}
				}
			}
		});

		/**
		 * 
		 * @param {cpr.events.CKeyboardEvent} e
		 */
		function fn_keyup(e) {
			var control = e.control;
			
			if("displayText" in control == false) return; // 인풋계열 컨트롤만 가능
			
			if(control.userAttr(ATTR_USE_ASSIST) == "Y") {
				/** @type cpr.core.AppInstance */
				var _app = control.getAppInstance();
				var vsText = control.displayText;
				if(control.type == "maskeditor") vsText = vsText.replace(/\_/gi, "");
				
				// 자연어 사용을 위해 wait 시간 설정
				if(!mbUseNatureLan) mnWait = 0;
				
				/**
				 * 입력값에 따라 서브미션/필터 분기
				 */
				function getItemData () {
					/*  검색 디바운스 */
					_.debounce(function(){
						var vsText = control.displayText;
						if(control.type == "maskeditor") vsText = vsText.replace(/\_/gi, "");
						var vnDefIndex = _getDefIndex(msBeforeValue, vsText);
						var vsSameText = vsText.slice(0, vnDefIndex);
						
						// 아무 텍스트도 입력하지 않은 경우 리턴
						if(msBeforeValue == vsText) return;
						
						// 지웠을 때 앞의 글자가 같으면 필터링 / 다르면 서브미션
						if(vsSameText == "") {
							_send(_app, control, vsText, msSort);
						} else {
							_setFilter(vsText);
						}
						
						// 입력 후 이전 입력값 수정될 수 있도록 수정
						msBeforeValue = vsText;
		   			}, mnWait)();
				}

				// 리스트박스, 데이터셋 생성
				_createAssist(_app);
				
				if(mcMenu == null || mcDataset == null) return;

				// keyCode 설정 START *************************************************************************************************
				if(e.keyCode == cpr.events.KeyCode.SHIFT || e.keyCode == cpr.events.KeyCode.TAB  || e.keyCode == cpr.events.KeyCode.ENTER) {
					_removeListBox();
					return;
				}
				
				if(e.keyCode == cpr.events.KeyCode.LEFT || e.keyCode == cpr.events.KeyCode.RIGHT) {
					return;
				}
				
				if(e.keyCode == cpr.events.KeyCode.BACKSPACE || e.keyCode == cpr.events.KeyCode.DELETE) {
					if(vsText.trim() == "" || vsText.trim() == null) {
						_removeListBox();
					} else {
						getItemData();
						_floatList(_app, control, e);
					} 
					return;
				}
				
				if(e.keyCode == cpr.events.KeyCode.ESC) {
					control.value = "";
					_removeListBox();
					return;
				}
				
				if(e.keyCode == cpr.events.KeyCode.DOWN) {
					if(mcMenu.isFloated()) {
						if(mcMenu.style.list.hasClass(msClBottomCls)) {
							mcMenu.focus();
						}
						return;
					}
				}
				
				if(e.keyCode == cpr.events.KeyCode.UP) {
					if(mcMenu.isFloated()) {
						if(mcMenu.style.list.hasClass(msClTopCls)) {
							mcMenu.focus();
						}
					}
					return;
				}
				
				// END **********************************************************************************************************************
				
				if(vsText.trim() == "" || vsText.trim() == null || msBeforeValue == vsText) {
					if(e.keyCode != cpr.events.KeyCode.DOWN) {
						 return; 
					}
				}

				getItemData();

				/*
				 * TODO 서브미션을 연동 할 경우에 아래의 _floatList 를 주석한 뒤 사용하시기 바랍니다.
				 * 리스트박스 플로팅
				 */
				//_floatList(_app, control, e);
				
				/* 이벤트 리스너 */
				if(mcMenu) {
					mcMenu.addEventListener("selection-change", function(e){
						control.value = e.newSelection[0].label;
						_removeListBox();
						control.focus();
						e.stopImmediatePropagation();
					});
					
					mcMenu.addEventListener("click", function(e){
						e.stopPropagation();
					});
				}
				
				_app.getRootAppInstance().getContainer().addEventListener("click", function(e){
					_removeListBox();
				});
			}
		}

		/**
		 * 리스트박스에 보여줄 최상위 개수를 지정합니다.
		 * @param {Number} pnRank
		 */
		globals.setRank = function(pnRank) {
			if(!isNaN(pnRank)) {
				mnRank = pnRank;
			}
		}

		/**
		 * 메뉴, 데이터셋 생성
		 * @param {cpr.core.AppInstance} poApp
		 */
		function _createAssist (poApp) {
			
			//지정 dataSet이 없을 경우 
			if( mcDataset == null){
				
				mcDataset = new cpr.data.DataSet("dsQuickSearch");
				mcDataset.parseData({
					"columns": [
						{"name": "label"},
						{"name": "value"}
					],
					// FIXME 서브미션 연동 시 row 삭제
				});
				console.log("mcDataset: ", mcDataset);
				poApp.register(mcDataset);
			}
			
			var vsLocalLabel  = "label";
			var vsLocalValue  = "value" ;
			var vsLocalTooltip = "label" ;
			
			if( msDataSetLabel != null ){
				vsLocalLabel = msDataSetLabel ;
			}
			if( msDataSetValue != null ){
				vsLocalValue = msDataSetValue ;
			}
			if( msDataSetTooltip != null ){
				vsLocalTooltip = msDataSetTooltip ;
			} 
			
			if(mcMenu == null) {
				mcMenu = new cpr.controls.Menu();
				mcMenu.style.list.setClasses([msClPopCls , msClBottomCls]);
				mcMenu.style.item.addClass(msEllipsisCls); // 말줄임 스타일
				mcMenu.style.addClass(msQuickSrchCls); // TODO 리스트박스의 클래스명을 작성하십시오.
				 
				 
				mcMenu.setItemSet(mcDataset, {
					label: vsLocalLabel,
					value: vsLocalValue,
					tooltip : vsLocalTooltip
				});
				
				mcMenu.addEventListener("keyup", function(e){
					if(e.keyCode == cpr.events.KeyCode.ESC) {
						_removeListBox();
					}
				});
			}
		}

		/**
		 * 변경된 텍스트의 인덱스 반환
		 * @param {String} psBefore
		 * @param {String} psAfter
		 */
		function _getDefIndex (psBefore, psAfter) {
			var vaBefore = psBefore.split("");
			var vaAfter = psAfter.split("");
			var vaStandard = vaBefore.length > vaAfter.length ? vaBefore : vaAfter;
			
			var vnIndex = 0;
			for(var idx = 0; idx < vaStandard.length; idx++){
				if(vaBefore[idx] != vaAfter[idx]) {
					vnIndex = idx;
					break;
				}
			}
			
			return vnIndex;
		}

		/**
		 * 리스트박스 삭제
		 */
		function _removeListBox () {
			if(mcMenu && mcMenu.isFloated()) {
				mcMenu.getParent().removeChild(mcMenu, true);
				mcMenu = null;
				mcDataset = null;
				
				// 모두 삭제 시 전역변수 초기화 추가
				msBeforeValue = ""; 
			}
		}

		/**
		 * 리스트박스 플로팅
		 * @param {cpr.core.AppInstance} poApp
		 * @param {cpr.controls.UIControl} pcControl
		 * @param {cpr.events.CKeyboardEvent} e
		 */
		function _floatList(poApp, pcControl, e) { 
			
			_.debounce(function(){
		  
				var voConstraint = poApp.getContainer().getConstraint(pcControl);
				var voActualRect = pcControl.getActualRect();
				var voOffsetRect = pcControl.getOffsetRect();
				var voAppRect = poApp.getContainer().getActualRect();
				var voRootRect = poApp.getRootAppInstance().getContainer().getActualRect();
				
				var voAnchor = {
					right : false,
					bottom : false
				}
				
				if(voConstraint) {
					if(voConstraint.right) voAnchor.right =true;
					if(voConstraint.bottom) voAnchor.bottom = true;
				}
				
				var vcContainer = pcControl.getParent();
				if(vcContainer.type != "container") vcContainer = vcContainer.getParent();
				var voParentRect = vcContainer.getActualRect();
				var voRealRect = _getRealRect(poApp, pcControl); // 메뉴의 실제 크기
				if(voRealRect) {
					
					var voRect = {
						top : (voActualRect.bottom + voRootRect.top + e.view.scrollY) + "px",
						left : voActualRect.left + voRootRect.left + "px",
						width : voRealRect.width  + "px",
						height :  voRealRect.height + "px",
						zIndex : 100
					}
					
					// 리스트가 아래에 플로팅 되었을 때 스타일 설정
					mcMenu.style.list.removeClass(msClTopCls);
					mcMenu.style.list.addClass(msClBottomCls);
				
					// 그리드 셀에 포함되어있는 경우 위치설정
					if(pcControl.getParent().type == "grid") {
						voRect.top = (voActualRect.bottom + e.view.scrollY) + "px"; 
						voRect.left = voActualRect.left + "px";
					}
					
					// left, width 설정
					if(voAppRect.width < parseInt(voRect.left) + voRealRect.width) {
						
						if(voAnchor.right) {
							// 오른쪽 기준
							var vnLeft = voActualRect.right - voRealRect.width - voRootRect.left;
							voRect.left = vnLeft + "px";
						} else {
							// 왼쪽 기준
							voRect.width = voRootRect.width - parseInt(voRect.left) - 2 + "px";
						}
						
					}
					
					var vnMaxHeight = (innerHeight - parseInt(voRect.top)) * 0.8; // 메뉴 최대 높이
					
					// top, height 설정
					if(innerHeight*0.8 < parseInt(voRect.top) + parseInt(voRect.height) - e.view.scrollY) {
						if(voActualRect.top > (innerHeight - parseInt(voRect.top))) { // 컨트롤 기준 위 아래 너비 비교 - 위쪽 공간이 더 넓을 때 위쪽으로 띄움
							vnMaxHeight =  (voActualRect.top - voRootRect.top) * 0.8;
							var vnHeight = voRealRect.height > vnMaxHeight ? vnMaxHeight : voRealRect.height;
							
							if(voAnchor.bottom) {
								// 리스트가 위에 플로팅 되었을 때 스타일 설정
								mcMenu.style.list.removeClass(msClBottomCls);
								mcMenu.style.list.addClass(msClTopCls);
								
								var vnTop =voActualRect.top + e.view.scrollY - vnHeight;
								voRect.top = vnTop + "px"; 
							} else {
								if(voParentRect.height < parseInt(voRect.top) + parseInt(voRect.height)) {
									voRect.top = voActualRect.top + e.view.scrollY - vnHeight + "px";
									mcMenu.style.list.removeClass(msClBottomCls);
									mcMenu.style.list.addClass(msClTopCls);
								}
							}
						}
					}

					if(mcMenu.getItemCount() > 0) {
						// 메뉴 최소, 최대 크기 설정
						mcMenu.style.list.css("min-width",voActualRect.width +"px");
						mcMenu.style.list.css("max-width", (voParentRect.width*0.8)+"px");
						mcMenu.style.list.css("max-height", vnMaxHeight+"px");
						
						if(parseInt(voRect.width) > (voParentRect.width*0.8)) voRect.width = voParentRect.width*0.8 + "px";
						if(parseInt(voRect.height) > vnMaxHeight) voRect.height = vnMaxHeight + "px";
						
						poApp.getRootAppInstance().getContainer().floatControl(mcMenu, voRect);
					} else {
						_removeListBox();
					}
				}
			
			}, mnWait)();
		}


		/**
		 * 실제 리스트박스의 크기 반환
		 * @param {cpr.core.AppInstance} poApp
		 * @param {cpr.controls.UIControl} pcControl
		 */
		function _getRealRect (poApp, pcControl) {
			
			if(mcMenu == null || mcDataset == null) return;
			
			var voActualRect = pcControl.getActualRect();
			var voRootRect = poApp.getRootAppInstance().getContainer().getActualRect();
			var voParentRect = pcControl.getParent().getActualRect();
			var vnMaxHeight = (innerHeight - (voActualRect.bottom + voRootRect.top)) * 0.8;
			
			var vcTempMenu = new cpr.controls.Menu("tempMenu");
			vcTempMenu.style.list.css("min-width",voActualRect.width +"px");
			vcTempMenu.style.list.css("max-width", (voParentRect.width*0.8)+"px");
			vcTempMenu.style.list.css("max-height", (innerHeight*0.8)+"px");
			
			vcTempMenu.style.addClass(msQuickSrchCls);
			
			vcTempMenu.setItemSet(mcDataset, {
				label : "label",
				value : "value"
			});
			
			vcTempMenu.setFilter(mcMenu.getFilter());
			poApp.getContainer().addChild(vcTempMenu, {
				top : "-10000px",
				left : "-10000px"
			});
			cpr.core.DeferredUpdateManager.INSTANCE.update();

			var width = vcTempMenu.getActualRect().width;
			var height = vcTempMenu.getActualRect().height;
			poApp.getContainer().removeChild(vcTempMenu);
			
			return {
				"width" : width,
				"height" : height
			};
		}


		/**
		 * 서브미션 생성 및  설정
		 * @param {cpr.core.AppInstance} poApp
		 * @param {cpr.controls.UIControl} pcCtrl
		 * @param {String} psParam? 필터조건
		 * @param {String} psSort? 정렬조건
		 */
		function _send (poApp, pcCtrl, psParam, psSort) {
			
			if(mcMenu == null || mcDataset == null) return; 
			
			var submission = new cpr.protocols.Submission();
			// TODO 서브미션의 경로를 설정하십시오.
			submission.action = pcCtrl.userAttr(ATTR_SUBMIT_ACTION);
			submission.mediaType 	= "application/x-www-form-urlencoded";
			submission.method = "post";
			submission.responseType = "text";
			submission.addResponseData(mcDataset, false);
			poApp.register(submission);
			
			if(psParam) {
				psParam = psParam.replace(/\\/gi, "");

				// TODO 서브미션을 연결할 경우 아래의 setFilter 구문은 삭제하십시오.
				//mcMenu.setFilter("label.toUpperCase() *= '" + psParam.toUpperCase() + "'");

				submission.setParameters("filter", psParam);
			}
			
			if(psSort) {
				// TODO 서브미션을 연결 할 경우 아래의 setSort 구문은 삭제하십시오.
				//mcDataset.setSort(msSort);
				
				submission.setParameters("sort", psSort);
			}
			
			// TODO 서브미션을 연결 할 경우 아래의 코드를 주석처리 하십시오.
		//	if(mnRank > 0) {
		//		var vnDsCnt = mcMenu.getItemCount();
		//		for(var idx = mnRank; idx <vnDsCnt ; idx++){
		//			mcMenu.deleteItem(mnRank);
		//		}
		//	}
				
			// TODO 서브미션을 보내기 위해서 아래의 주석을 해제하십시오.
			submission.addEventListener("submit-done", function(e){	
				
				if(mnRank > 0) {
					var vnDsCnt = mcMenu.getItemCount();
					for(var idx = mnRank; idx <vnDsCnt ; idx++){
						mcMenu.deleteItem(mnRank);
					}
				}
				
				_floatList(poApp, pcCtrl);
				mcMenu.redraw();
			});
			submission.send();
		}


		/**
		 * 메뉴 데이터 필터링
		 * @param {String} psText
		 */
		function _setFilter(psText) {
			
			if(mcMenu == null || mcDataset == null) return; 
			
			// 대소문자 구분하지 않고 모든 값에 대해 필터링
			psText = psText.replace(/\\/gi, "");
			mcMenu.setFilter("label.toUpperCase() *= '" + psText.toUpperCase() + "'");
			mcDataset.setSort(msSort);
			
			if(mnRank > 0) {
				var vnDsCnt = mcMenu.getItemCount();
				for(var idx = mnRank; idx <vnDsCnt ; idx++){
					mcMenu.deleteItem(mnRank);
				}
			}

			mcMenu.redraw();
		}

		/**
		 * 브라우저 사이즈가 변경될 때마다 퀵서치를 삭제합니다.
		 */
		window.addEventListener("resize", function(e){
			_removeListBox();
		});

		/**
		 * 스크롤 시 퀵서치를 삭제합니다.
		 */
		cpr.events.EventBus.INSTANCE.addFilter("scroll", function(e){
			var control = e.control;
			if(mcMenu && mcMenu.focused) return;
			
		//	_removeListBox();
		});
	});
})();
/// end - module/quicksearch/quickSearch
/// start - module/recipe/createRecipeCard
/*
 * Module URI: module/recipe/createRecipeCard
 * SRC: module/recipe/createRecipeCard.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/recipe/createRecipeCard", function(exports, globals, module){
		/************************************************
		 * createRecipeCard.module.js
		 * Created at 2025. 4. 22. 오전 11:30:01.
		 *
		 * @author gyrud
		 ************************************************/

		const createRecipeCard=(resultJson, recipeContainer, recommendRecipe = false)=> {
			for (let i = 0; i < resultJson.length; i++) {
				const data = recommendRecipe ? resultJson[i].recipeSummary : resultJson[i];
				
				const recipeCard = new udc.recipe.recipe_card();
				recipeCard.title = data.recipeName;
				recipeCard.difficulty = data.difficulty;
				recipeCard.cookingTime = data.cookingTime;
				recipeCard.author = data.userNickname;
				recipeCard.likesCount = data.likeCount;
				recipeCard.recipeImg = data.fileUrl;
				recipeCard.calories = data.calories+"kcal";
				recipeCard.recipeId = data.id;
				
				const categories = data.categories;
				for (let j = 0; j < categories.length; j++) {
				  const category = categories[j];
				  switch (category.recipeCategoryType) {
				    case "종류별":
				      recipeCard.typeCategory = "#" + category.recipeCategoryName;
				      break;
				    case "상황별":
				      recipeCard.situationCategory = "#" + category.recipeCategoryName;
				      break;
				    case "방법별":
				      recipeCard.methodCategory = "#" + category.recipeCategoryName;
				      break;
				    default:
				      break;
				  }
				}
				
				if(recommendRecipe) {
					recipeContainer[i].addChild(recipeCard, {
					  width: "250px",
					  height: "400px",
					});		
				} else {
					recipeContainer.addChild(recipeCard, {
					  width: "250px",
					  height: "400px",
					});		
				}	
			}
		}

		const createRecommendRecipeCard=(resultJson, recipeContainer)=> {
			const recipeGroupList = [];
			
			for (let i = 0; i < resultJson.length; i++) {
				// 버티컬 레이아웃 생성
				const recipeGroup = new cpr.controls.Container("recipeGroup");
				const recipeLayout = new cpr.controls.layouts.VerticalLayout();
				recipeLayout.spacing = "10px";
				recipeGroup.setLayout(recipeLayout);
				
				// 아웃풋 설정
				const matchedIngredients = resultJson[i].matchedIngredients;
				const similarityOutput = new udc.recipe.recipe_similarity_output();

				similarityOutput.value = `냉장고 재료와 ${matchedIngredients}개 일치!`;
				
				recipeGroup.addChild(similarityOutput, {
				  width: "250px",
				  height: "30px",
				});	
						
				// 버티컬 레이아웃 배열에 넣기
				recipeGroupList.push(recipeGroup);	
			}
			
			// 레시피 카드 넣기
			createRecipeCard(resultJson, recipeGroupList, true);
			
			// 레시피 그룹 Container에 넣기
			for (let i = 0; i < recipeGroupList.length; i++) {
				recipeContainer.addChild(recipeGroupList[i], {
					  width: "250px",
					  height: "440px",
				});		
			}
		}

		exports.createRecipeCard = createRecipeCard;
		exports.createRecommendRecipeCard = createRecommendRecipeCard;
	});
})();
/// end - module/recipe/createRecipeCard
/// start - module/recipe/setRecipeList
/*
 * Module URI: module/recipe/setRecipeList
 * SRC: module/recipe/setRecipeList.module.js
 *
 * This file was generated by eXBuilder6 compiler(1.0.5545), Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/recipe/setRecipeList", function(exports, globals, module){
		/************************************************
		 * setRecipeList.module.js
		 * Created at 2025. 4. 28. 오후 7:17:04.
		 *
		 * @author gyrud
		 ************************************************/

		const createRecipeCardModule = cpr.core.Module.require("module/recipe/createRecipeCard");
		const createRecipeCard = createRecipeCardModule.createRecipeCard;

		const setRecipeList=(submission, recipeContainer, recipeGroup, pageIndexer)=> {
			if(recipeContainer.getChildrenCount()){
				recipeContainer.removeAllChildren();
			}
				
			const result = submission.xhr.responseText;
			const resultJson = JSON.parse(result);
			
			createRecipeCard(resultJson.content, recipeContainer);
			pageIndexer.totalRowCount = resultJson.totalElements;
			pageIndexer.startPageIndex = resultJson.size;
			pageIndexer.currentPageIndex = (resultJson.number)+1;
				
			recipeGroup.redraw();
		}

		exports.setRecipeList = setRecipeList;
	});
})();
/// end - module/recipe/setRecipeList
